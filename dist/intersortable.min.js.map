{
  "version": 3,
  "sources": ["intersortable.js"],
  "sourcesContent": ["// intersortable.ts - Novel approach to sortable lists between containers\n// Global state\nlet isDragging = false;\nlet draggedElement = null;\nlet clonedElement = null;\nconst dragHandleOffset = { x: 0, y: 0 };\nlet draggedItemCenter = { x: 0, y: 0 };\nlet targetedItem = null;\nlet insertionPosition = 'above';\nlet lastTargetedItem = null;\nlet lastInsertionPosition = 'above';\n// Configuration\nlet config = {};\n// Helper functions\nfunction calculateDistance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n}\nfunction getElementCenter(element) {\n    const rect = element.getBoundingClientRect();\n    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };\n}\nfunction setupClone(clone, item, mouseX, mouseY, handleOffset) {\n    clone.removeAttribute('data-intersortable-item');\n    // Add class for CSS targeting\n    clone.classList.add('intersortable-clone');\n    clone.setAttribute('data-intersortable-state', 'clone');\n    // Base positioning and sizing (always needed)\n    clone.style.position = 'fixed';\n    clone.style.pointerEvents = 'none';\n    clone.style.left = (mouseX - handleOffset.x) + 'px';\n    clone.style.top = (mouseY - handleOffset.y) + 'px';\n    clone.style.width = item.offsetWidth + 'px';\n    clone.style.height = item.offsetHeight + 'px';\n    // Customizable styles using CSS custom properties\n    clone.style.zIndex = 'var(--intersortable-clone-z-index, 9999)';\n    clone.style.opacity = 'var(--intersortable-clone-opacity, 1)';\n    clone.style.transform = 'scale(var(--intersortable-clone-scale, 1.05))';\n    clone.style.boxShadow = 'var(--intersortable-clone-shadow, 0 10px 25px rgba(0, 0, 0, 0.3))';\n    clone.style.transition = 'var(--intersortable-clone-transition, none)';\n}\nfunction resetDragState() {\n    isDragging = false;\n    document.body.style.cursor = 'var(--intersortable-cursor-default, auto)';\n    targetedItem = null;\n    lastTargetedItem = null;\n    lastInsertionPosition = 'above';\n    // Clean up any transition styles left on items\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        // Remove dragging classes and attributes\n        item.classList.remove('intersortable-dragging');\n        item.removeAttribute('data-intersortable-state');\n        setTimeout(() => {\n            item.style.transition = '';\n            item.style.transform = '';\n        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '250')); // Use CSS custom property or default\n    });\n}\n// Function to move an item to the insertion point with smooth animations\nfunction moveItemToInsertionPoint(itemToMove, targetItem, position) {\n    // FLIP technique: First - capture current positions of all affected items\n    const affectedItems = [];\n    // Find all sortable items that might be affected by this move\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        if (item !== itemToMove) { // Don't track the dragged item itself\n            affectedItems.push({\n                element: item,\n                rect: item.getBoundingClientRect()\n            });\n        }\n    });\n    // Capture the moving item's current position\n    const movingItemRect = itemToMove.getBoundingClientRect();\n    // Remove the item from its current position\n    if (itemToMove.parentNode) {\n        itemToMove.parentNode.removeChild(itemToMove);\n    }\n    // Check if target is an empty container (data-intersortable-container attribute)\n    if (targetItem.hasAttribute('data-intersortable-container')) {\n        // Empty container - just append the item to it\n        targetItem.appendChild(itemToMove);\n    }\n    else {\n        // Normal item-to-item insertion\n        const targetParent = targetItem.parentNode;\n        if (!targetParent)\n            return;\n        // Insert directly relative to the target item\n        if (position === 'above') {\n            targetParent.insertBefore(itemToMove, targetItem);\n        }\n        else {\n            // Insert after the target item\n            const nextSibling = targetItem.nextSibling;\n            if (nextSibling) {\n                targetParent.insertBefore(itemToMove, nextSibling);\n            }\n            else {\n                targetParent.appendChild(itemToMove);\n            }\n        }\n    }\n    // FLIP technique: Last - get new positions, Invert - calculate differences, Play - animate\n    const newMovingItemRect = itemToMove.getBoundingClientRect();\n    // Animate the moving item from its old position to new position\n    const deltaX = movingItemRect.left - newMovingItemRect.left;\n    const deltaY = movingItemRect.top - newMovingItemRect.top;\n    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n        itemToMove.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n        itemToMove.style.transition = 'none';\n        requestAnimationFrame(() => {\n            const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '0.2s';\n            const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n            itemToMove.style.transition = `transform ${duration} ${easing}`;\n            itemToMove.style.transform = 'translate(0, 0)';\n        });\n    }\n    // Animate displaced items\n    affectedItems.forEach(({ element, rect }) => {\n        const newRect = element.getBoundingClientRect();\n        const deltaX = rect.left - newRect.left;\n        const deltaY = rect.top - newRect.top;\n        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n            element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n            element.style.transition = 'none';\n            requestAnimationFrame(() => {\n                const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-displaced-duration') || '0.15s';\n                const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n                element.style.transition = `transform ${duration} ${easing}`;\n                element.style.transform = 'translate(0, 0)';\n            });\n        }\n    });\n}\n// Calculate targeting for real-time item movement\nfunction calculateTargeting() {\n    // Calculate dragged item center position\n    if (clonedElement) {\n        draggedItemCenter = getElementCenter(clonedElement);\n    }\n    // Find all sortable items and calculate distances\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    let nearestTarget = null;\n    let nearestDistance = Infinity;\n    // Check all sortable items\n    allItems.forEach(item => {\n        const itemCenter = getElementCenter(item);\n        const distance = calculateDistance(itemCenter, draggedItemCenter);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestTarget = item;\n        }\n    });\n    // Also check empty containers\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    containers.forEach(container => {\n        const sortableItems = container.querySelectorAll('[data-intersortable-item]');\n        if (sortableItems.length === 0) { // Empty container\n            const containerCenter = getElementCenter(container);\n            const distance = calculateDistance(containerCenter, draggedItemCenter);\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                nearestTarget = container;\n            }\n        }\n    });\n    const nearestItem = nearestTarget;\n    targetedItem = nearestItem;\n    // Calculate insertion position based on dragged item center vs nearest item center\n    if (nearestItem) {\n        if (nearestItem === draggedElement) {\n            // Targeting self - no change needed\n            insertionPosition = 'above';\n        }\n        else {\n            const targetCenter = getElementCenter(nearestItem);\n            insertionPosition = draggedItemCenter.y <= targetCenter.y ? 'above' : 'below';\n        }\n    }\n    // Move the original dragged element to the insertion point in real-time\n    // Only move if the target or position has changed\n    if (nearestItem && draggedElement && nearestItem !== draggedElement) {\n        if (nearestItem !== lastTargetedItem || insertionPosition !== lastInsertionPosition) {\n            const oldContainerId = (config.getContainerId || defaultGetContainerId)(draggedElement);\n            moveItemToInsertionPoint(draggedElement, nearestItem, insertionPosition);\n            // Call onMove callback if provided\n            if (config.onMove) {\n                const itemId = (config.getItemId || defaultGetItemId)(draggedElement);\n                const newContainerId = (config.getContainerId || defaultGetContainerId)(draggedElement);\n                const allContainers = getCurrentSortOrder();\n                const newIndex = allContainers[newContainerId]?.indexOf(itemId) ?? -1;\n                if (itemId && oldContainerId && newContainerId) {\n                    config.onMove({\n                        itemId,\n                        fromContainer: oldContainerId,\n                        toContainer: newContainerId,\n                        newIndex,\n                        allContainers\n                    });\n                }\n            }\n            lastTargetedItem = nearestItem;\n            lastInsertionPosition = insertionPosition;\n        }\n    }\n}\n// Default helper functions\nfunction defaultGetItemId(element) {\n    return element.dataset.itemId || element.id || '';\n}\nfunction defaultGetContainerId(element) {\n    const container = element.closest('[data-intersortable-container]');\n    return container?.dataset.containerId || container?.id || '';\n}\n// Helper function to get current sort order\nfunction getCurrentSortOrder() {\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    const sortOrder = {};\n    containers.forEach(container => {\n        const containerId = (config.getContainerId || defaultGetContainerId)(container);\n        if (containerId) {\n            const items = container.querySelectorAll('[data-intersortable-item]');\n            sortOrder[containerId] = Array.from(items).map(item => (config.getItemId || defaultGetItemId)(item)).filter(id => id); // Filter out empty IDs\n        }\n    });\n    return sortOrder;\n}\nexport function initSortable(userConfig = {}) {\n    config = { ...userConfig };\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n}\nfunction handleMouseDown(e) {\n    const target = e.target;\n    let dragHandle = null;\n    let item = null;\n    // First, check if clicked element is or contains a drag handle\n    if (target.closest('[data-drag-handle]')) {\n        dragHandle = target.closest('[data-drag-handle]');\n        item = dragHandle.closest('[data-intersortable-item]');\n    }\n    else {\n        // No drag handle found, check if we clicked directly on a sortable item\n        item = target.closest('[data-intersortable-item]');\n        if (item) {\n            // Check if this item has a drag handle - if so, ignore clicks outside the handle\n            const hasHandle = item.querySelector('[data-drag-handle]');\n            if (hasHandle) {\n                return; // Item has a handle but we didn't click on it, so don't start drag\n            }\n            // No handle exists, so the entire item is draggable\n            dragHandle = item;\n        }\n    }\n    if (item && dragHandle) {\n        isDragging = true;\n        draggedElement = item;\n        // Reset tracking variables for real-time movement\n        lastTargetedItem = null;\n        lastInsertionPosition = 'above';\n        // Calculate drag handle offset - always preserve click position\n        const itemRect = item.getBoundingClientRect();\n        dragHandleOffset.x = e.clientX - itemRect.left;\n        dragHandleOffset.y = e.clientY - itemRect.top;\n        // Create clone\n        clonedElement = item.cloneNode(true);\n        setupClone(clonedElement, item, e.clientX, e.clientY, dragHandleOffset);\n        document.body.appendChild(clonedElement);\n        // Calculate initial targeting\n        calculateTargeting();\n        // Add dragging state\n        item.classList.add('intersortable-dragging');\n        item.setAttribute('data-intersortable-state', 'dragging');\n        // Apply dragging styles with CSS custom properties\n        item.style.opacity = 'var(--intersortable-dragging-opacity, 0.4)';\n        // Set cursor to grabbing\n        document.body.style.cursor = 'var(--intersortable-cursor-grabbing, grabbing)';\n        e.preventDefault();\n    }\n}\nfunction handleMouseMove(e) {\n    if (isDragging && clonedElement) {\n        // Move clone so drag handle follows cursor\n        const cloneX = e.clientX - dragHandleOffset.x;\n        const cloneY = e.clientY - dragHandleOffset.y;\n        clonedElement.style.left = cloneX + 'px';\n        clonedElement.style.top = cloneY + 'px';\n        // Update targeting calculations\n        calculateTargeting();\n    }\n}\nfunction handleMouseUp(_e) {\n    if (isDragging) {\n        // Call onComplete callback before cleanup\n        if (config.onComplete) {\n            const allContainers = getCurrentSortOrder();\n            config.onComplete(allContainers);\n        }\n        // Cleanup\n        if (clonedElement) {\n            clonedElement.classList.remove('intersortable-clone');\n            clonedElement.removeAttribute('data-intersortable-state');\n            document.body.removeChild(clonedElement);\n            clonedElement = null;\n        }\n        if (draggedElement) {\n            draggedElement.style.opacity = '1';\n            draggedElement.classList.remove('intersortable-dragging');\n            draggedElement.removeAttribute('data-intersortable-state');\n            draggedElement = null;\n        }\n        resetDragState();\n    }\n}\nexport function restoreSortOrder(savedOrder) {\n    Object.entries(savedOrder).forEach(([containerId, itemIds]) => {\n        const container = document.querySelector(`[data-container-id=\"${containerId}\"], #${containerId}`);\n        if (!container)\n            return;\n        // Create a map of current items by their IDs for quick lookup\n        const currentItems = new Map();\n        const items = container.querySelectorAll('[data-intersortable-item]');\n        items.forEach(item => {\n            const itemId = (config.getItemId || defaultGetItemId)(item);\n            if (itemId)\n                currentItems.set(itemId, item);\n        });\n        // Reorder items according to saved order\n        itemIds.forEach(itemId => {\n            const item = currentItems.get(itemId);\n            if (item) {\n                container.appendChild(item); // This moves the item to the end\n            }\n        });\n    });\n}\nexport function cleanupSortable() {\n    document.removeEventListener('mousedown', handleMouseDown);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n}\n"],
  "mappings": "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",
  "names": ["isDragging", "draggedElement", "clonedElement", "dragHandleOffset", "draggedItemCenter", "targetedItem", "insertionPosition", "lastTargetedItem", "lastInsertionPosition", "config", "calculateDistance", "point1", "point2", "getElementCenter", "element", "rect", "setupClone", "clone", "item", "mouseX", "mouseY", "handleOffset", "resetDragState", "moveItemToInsertionPoint", "itemToMove", "targetItem", "position", "affectedItems", "movingItemRect", "targetParent", "nextSibling", "newMovingItemRect", "deltaX", "deltaY", "duration", "easing", "newRect", "calculateTargeting", "allItems", "nearestTarget", "nearestDistance", "itemCenter", "distance", "container", "containerCenter", "nearestItem", "targetCenter", "oldContainerId", "defaultGetContainerId", "itemId", "defaultGetItemId", "newContainerId", "allContainers", "getCurrentSortOrder", "newIndex", "containers", "sortOrder", "containerId", "items", "id", "userConfig", "handleMouseDown", "handleMouseMove", "handleMouseUp", "e", "target", "dragHandle", "itemRect", "cloneX", "cloneY", "_e", "savedOrder", "itemIds", "currentItems"]
}

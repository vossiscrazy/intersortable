{
  "version": 3,
  "sources": ["intersortable.js"],
  "sourcesContent": ["// intersortable.ts - Novel approach to sortable lists between containers\n// Global state\nlet isDragging = false;\nlet draggedElement = null;\nlet draggedHandle = null;\nlet clonedElement = null;\nconst dragHandleOffset = { x: 0, y: 0 };\nlet draggedItemCenter = { x: 0, y: 0 };\nlet targetedItem = null;\nlet insertionPosition = 'above';\nlet lastTargetedItem = null;\nlet lastInsertionPosition = 'above';\n// Configuration\nlet config = {};\n// MutationObserver for detecting new items\nlet mutationObserver = null;\n// Helper functions\nfunction calculateDistance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n}\nfunction getElementCenter(element) {\n    const rect = element.getBoundingClientRect();\n    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };\n}\nfunction setupClone(clone, item, mouseX, mouseY, handleOffset) {\n    clone.removeAttribute('data-intersortable-item');\n    // Add class for CSS targeting\n    clone.classList.add('intersortable-clone');\n    clone.setAttribute('data-intersortable-state', 'clone');\n    // Base positioning and sizing (always needed)\n    clone.style.position = 'fixed';\n    clone.style.pointerEvents = 'none';\n    clone.style.left = (mouseX - handleOffset.x) + 'px';\n    clone.style.top = (mouseY - handleOffset.y) + 'px';\n    clone.style.width = item.offsetWidth + 'px';\n    clone.style.height = item.offsetHeight + 'px';\n    // Customizable styles using CSS custom properties\n    clone.style.zIndex = 'var(--intersortable-clone-z-index, 9999)';\n    clone.style.opacity = 'var(--intersortable-clone-opacity, 1)';\n    clone.style.transform = 'scale(var(--intersortable-clone-scale, 1.05))';\n    clone.style.boxShadow = 'var(--intersortable-clone-shadow, 0 10px 25px rgba(0, 0, 0, 0.3))';\n    clone.style.transition = 'var(--intersortable-clone-transition, none)';\n}\nfunction resetDragState() {\n    isDragging = false;\n    document.body.style.cursor = 'var(--intersortable-cursor-default, auto)';\n    targetedItem = null;\n    lastTargetedItem = null;\n    lastInsertionPosition = 'above';\n    // Clean up any transition styles left on items and restore pointer events\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        // Remove dragging classes and attributes\n        item.classList.remove('intersortable-dragging');\n        item.removeAttribute('data-intersortable-state');\n        // Restore pointer events\n        item.style.pointerEvents = '';\n        // Also restore pointer events on drag handles\n        const handles = item.querySelectorAll('[data-drag-handle]');\n        handles.forEach(handle => {\n            handle.style.pointerEvents = '';\n        });\n        setTimeout(() => {\n            item.style.transition = '';\n            item.style.transform = '';\n        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '250')); // Use CSS custom property or default\n    });\n}\n// Function to move an item to the insertion point with smooth animations\nfunction moveItemToInsertionPoint(itemToMove, targetItem, position) {\n    // Store original container before DOM manipulation for onMove callback\n    const originalFromContainer = (config.getContainerId || defaultGetContainerId)(itemToMove);\n    const targetToContainer = targetItem.hasAttribute('data-intersortable-container')\n        ? (config.getContainerId || defaultGetContainerId)(targetItem)\n        : (config.getContainerId || defaultGetContainerId)(targetItem.closest('[data-intersortable-container]') || targetItem);\n    // Call onDOMStart callback before any DOM manipulation\n    if (config.onDOMStart) {\n        const itemId = (config.getItemId || defaultGetItemId)(itemToMove);\n        config.onDOMStart({ itemId, fromContainer: originalFromContainer, toContainer: targetToContainer });\n    }\n    // FLIP technique: First - capture current positions of all affected items\n    const affectedItems = [];\n    // Find all sortable items that might be affected by this move\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        if (item !== itemToMove) { // Don't track the dragged item itself\n            affectedItems.push({\n                element: item,\n                rect: item.getBoundingClientRect()\n            });\n        }\n    });\n    // Capture the moving item's current position\n    const movingItemRect = itemToMove.getBoundingClientRect();\n    // Remove the item from its current position\n    if (itemToMove.parentNode) {\n        itemToMove.parentNode.removeChild(itemToMove);\n    }\n    // Check if target is an empty container (data-intersortable-container attribute)\n    if (targetItem.hasAttribute('data-intersortable-container')) {\n        // Empty container - just append the item to it\n        targetItem.appendChild(itemToMove);\n    }\n    else {\n        // Normal item-to-item insertion\n        const targetParent = targetItem.parentNode;\n        if (!targetParent)\n            return;\n        // Insert directly relative to the target item\n        if (position === 'above') {\n            targetParent.insertBefore(itemToMove, targetItem);\n        }\n        else {\n            // Insert after the target item\n            const nextSibling = targetItem.nextSibling;\n            if (nextSibling) {\n                targetParent.insertBefore(itemToMove, nextSibling);\n            }\n            else {\n                targetParent.appendChild(itemToMove);\n            }\n        }\n    }\n    // Call onDOMComplete callback after DOM manipulation is complete\n    if (config.onDOMComplete) {\n        const allContainers = getCurrentSortOrder();\n        config.onDOMComplete(allContainers);\n    }\n    // Call onMove callback for real-time React state updates\n    if (config.onMove) {\n        const itemId = (config.getItemId || defaultGetItemId)(itemToMove);\n        const allContainers = getCurrentSortOrder();\n        const newIndex = allContainers[targetToContainer]?.indexOf(itemId) ?? -1;\n        config.onMove({\n            itemId,\n            fromContainer: originalFromContainer, // Where it came from (stored before DOM manipulation)\n            toContainer: targetToContainer, // Where it went to (calculated before DOM manipulation)\n            newIndex,\n            allContainers\n        });\n    }\n    // FLIP technique: Last - get new positions, Invert - calculate differences, Play - animate\n    const newMovingItemRect = itemToMove.getBoundingClientRect();\n    // Animate the moving item from its old position to new position\n    const deltaX = movingItemRect.left - newMovingItemRect.left;\n    const deltaY = movingItemRect.top - newMovingItemRect.top;\n    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n        itemToMove.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n        itemToMove.style.transition = 'none';\n        requestAnimationFrame(() => {\n            const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '0.2s';\n            const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n            itemToMove.style.transition = `transform ${duration} ${easing}`;\n            itemToMove.style.transform = 'translate(0, 0)';\n        });\n    }\n    // Animate displaced items\n    affectedItems.forEach(({ element, rect }) => {\n        const newRect = element.getBoundingClientRect();\n        const deltaX = rect.left - newRect.left;\n        const deltaY = rect.top - newRect.top;\n        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n            element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n            element.style.transition = 'none';\n            requestAnimationFrame(() => {\n                const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-displaced-duration') || '0.15s';\n                const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n                element.style.transition = `transform ${duration} ${easing}`;\n                element.style.transform = 'translate(0, 0)';\n            });\n        }\n    });\n}\n// Calculate targeting for real-time item movement\nfunction calculateTargeting() {\n    // Calculate dragged item center position\n    if (clonedElement) {\n        draggedItemCenter = getElementCenter(clonedElement);\n    }\n    // Find all sortable items and calculate distances\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    let nearestTarget = null;\n    let nearestDistance = Infinity;\n    // Check all sortable items\n    allItems.forEach(item => {\n        const itemCenter = getElementCenter(item);\n        const distance = calculateDistance(itemCenter, draggedItemCenter);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestTarget = item;\n        }\n    });\n    // Also check empty containers\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    containers.forEach(container => {\n        const sortableItems = container.querySelectorAll('[data-intersortable-item]');\n        if (sortableItems.length === 0) { // Empty container\n            const containerCenter = getElementCenter(container);\n            const distance = calculateDistance(containerCenter, draggedItemCenter);\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                nearestTarget = container;\n            }\n        }\n    });\n    const nearestItem = nearestTarget;\n    targetedItem = nearestItem;\n    // Calculate insertion position based on dragged item center vs nearest item center\n    if (nearestItem) {\n        if (nearestItem === draggedElement) {\n            // Targeting self - no change needed\n            insertionPosition = 'above';\n        }\n        else {\n            const targetCenter = getElementCenter(nearestItem);\n            insertionPosition = draggedItemCenter.y <= targetCenter.y ? 'above' : 'below';\n        }\n    }\n    // Move the original dragged element to the insertion point in real-time\n    // Only move if the target or position has changed\n    if (nearestItem && draggedElement && nearestItem !== draggedElement) {\n        if (nearestItem !== lastTargetedItem || insertionPosition !== lastInsertionPosition) {\n            moveItemToInsertionPoint(draggedElement, nearestItem, insertionPosition);\n            lastTargetedItem = nearestItem;\n            lastInsertionPosition = insertionPosition;\n        }\n    }\n}\n// Default helper functions\nfunction defaultGetItemId(element) {\n    return element.dataset.itemId || element.id || '';\n}\nfunction defaultGetContainerId(element) {\n    const container = element.closest('[data-intersortable-container]');\n    return container?.dataset.containerId || container?.id || '';\n}\n// Helper function to get current sort order\nfunction getCurrentSortOrder() {\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    const sortOrder = {};\n    containers.forEach(container => {\n        const containerId = (config.getContainerId || defaultGetContainerId)(container);\n        if (containerId) {\n            const items = container.querySelectorAll('[data-intersortable-item]');\n            sortOrder[containerId] = Array.from(items).map(item => (config.getItemId || defaultGetItemId)(item)).filter(id => id); // Filter out empty IDs\n        }\n    });\n    return sortOrder;\n}\nfunction applyCursorStyles() {\n    // Apply default grab cursor to all intersortable items\n    const items = document.querySelectorAll('[data-intersortable-item]');\n    items.forEach(item => {\n        applyCursorStyleToItem(item);\n    });\n}\nfunction applyCursorStyleToItem(item) {\n    // Check if item has a drag handle\n    const hasHandle = item.querySelector('[data-drag-handle]');\n    if (hasHandle) {\n        // Item has handle - only the handle should be grabbable\n        const handles = item.querySelectorAll('[data-drag-handle]');\n        handles.forEach(handle => {\n            if (!handle.style.cursor) {\n                handle.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n            }\n        });\n    }\n    else {\n        // No handle - entire item is grabbable\n        if (!item.style.cursor) {\n            item.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n        }\n    }\n}\nfunction handleMutations(mutations) {\n    mutations.forEach(mutation => {\n        // Handle added nodes\n        mutation.addedNodes.forEach(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                const element = node;\n                // Check if the added node is an intersortable item\n                if (element.hasAttribute('data-intersortable-item')) {\n                    applyCursorStyleToItem(element);\n                }\n                // Check if the added node contains intersortable items\n                const items = element.querySelectorAll('[data-intersortable-item]');\n                items.forEach(item => {\n                    applyCursorStyleToItem(item);\n                });\n                // Check if the added node is a drag handle\n                if (element.hasAttribute('data-drag-handle')) {\n                    if (!element.style.cursor) {\n                        element.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n                    }\n                }\n                // Check if the added node contains drag handles\n                const handles = element.querySelectorAll('[data-drag-handle]');\n                handles.forEach(handle => {\n                    if (!handle.style.cursor) {\n                        handle.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n                    }\n                });\n            }\n        });\n    });\n}\nfunction setupMutationObserver() {\n    // Clean up existing observer if any\n    if (mutationObserver) {\n        mutationObserver.disconnect();\n    }\n    // Create new observer\n    mutationObserver = new MutationObserver(handleMutations);\n    // Start observing the document for changes\n    mutationObserver.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n}\nfunction cleanupMutationObserver() {\n    if (mutationObserver) {\n        mutationObserver.disconnect();\n        mutationObserver = null;\n    }\n}\nexport function initSortable(userConfig = {}) {\n    config = { ...userConfig };\n    // Apply default cursor styles to intersortable items\n    applyCursorStyles();\n    // Set up MutationObserver to watch for new items\n    setupMutationObserver();\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n}\nfunction handleMouseDown(e) {\n    const target = e.target;\n    let dragHandle = null;\n    let item = null;\n    // First, check if clicked element is or contains a drag handle\n    if (target.closest('[data-drag-handle]')) {\n        dragHandle = target.closest('[data-drag-handle]');\n        item = dragHandle.closest('[data-intersortable-item]');\n    }\n    else {\n        // No drag handle found, check if we clicked directly on a sortable item\n        item = target.closest('[data-intersortable-item]');\n        if (item) {\n            // Check if this item has a drag handle - if so, ignore clicks outside the handle\n            const hasHandle = item.querySelector('[data-drag-handle]');\n            if (hasHandle) {\n                return; // Item has a handle but we didn't click on it, so don't start drag\n            }\n            // No handle exists, so the entire item is draggable\n            dragHandle = item;\n        }\n    }\n    if (item && dragHandle) {\n        isDragging = true;\n        draggedElement = item;\n        draggedHandle = dragHandle;\n        // Call onDragStart callback\n        if (config.onDragStart) {\n            const itemId = (config.getItemId || defaultGetItemId)(item);\n            config.onDragStart({ itemId, element: item });\n        }\n        // Reset tracking variables for real-time movement\n        lastTargetedItem = null;\n        lastInsertionPosition = 'above';\n        // Calculate drag handle offset - always preserve click position\n        const itemRect = item.getBoundingClientRect();\n        dragHandleOffset.x = e.clientX - itemRect.left;\n        dragHandleOffset.y = e.clientY - itemRect.top;\n        // Create clone\n        clonedElement = item.cloneNode(true);\n        setupClone(clonedElement, item, e.clientX, e.clientY, dragHandleOffset);\n        document.body.appendChild(clonedElement);\n        // Calculate initial targeting\n        calculateTargeting();\n        // Add dragging state\n        item.classList.add('intersortable-dragging');\n        item.setAttribute('data-intersortable-state', 'dragging');\n        // Apply dragging styles with CSS custom properties\n        item.style.opacity = 'var(--intersortable-dragging-opacity, 0.4)';\n        // Set cursor to grabbing on body and the specific draggable element\n        document.body.style.cursor = 'var(--intersortable-cursor-grabbing, grabbing)';\n        dragHandle.style.cursor = 'var(--intersortable-cursor-grabbing, grabbing)';\n        // Disable pointer events on all other intersortable items to prevent cursor conflicts\n        const allItems = document.querySelectorAll('[data-intersortable-item]');\n        allItems.forEach(otherItem => {\n            if (otherItem !== item) {\n                otherItem.style.pointerEvents = 'none';\n                // Also disable pointer events on their drag handles\n                const otherHandles = otherItem.querySelectorAll('[data-drag-handle]');\n                otherHandles.forEach(handle => {\n                    handle.style.pointerEvents = 'none';\n                });\n            }\n        });\n        e.preventDefault();\n    }\n}\nfunction handleMouseMove(e) {\n    if (isDragging && clonedElement) {\n        // Move clone so drag handle follows cursor\n        const cloneX = e.clientX - dragHandleOffset.x;\n        const cloneY = e.clientY - dragHandleOffset.y;\n        clonedElement.style.left = cloneX + 'px';\n        clonedElement.style.top = cloneY + 'px';\n        // Update targeting calculations\n        calculateTargeting();\n    }\n}\nfunction handleMouseUp(_e) {\n    if (isDragging) {\n        // Call onDragEnd callback before cleanup\n        if (config.onDragEnd) {\n            config.onDragEnd();\n        }\n        // Cleanup\n        if (clonedElement) {\n            clonedElement.classList.remove('intersortable-clone');\n            clonedElement.removeAttribute('data-intersortable-state');\n            document.body.removeChild(clonedElement);\n            clonedElement = null;\n        }\n        if (draggedElement) {\n            draggedElement.style.opacity = '1';\n            draggedElement.classList.remove('intersortable-dragging');\n            draggedElement.removeAttribute('data-intersortable-state');\n            draggedElement = null;\n        }\n        if (draggedHandle) {\n            // Reset cursor on the specific handle that was dragged\n            draggedHandle.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n            draggedHandle = null;\n        }\n        resetDragState();\n    }\n}\nexport function restoreSortOrder(savedOrder) {\n    Object.entries(savedOrder).forEach(([containerId, itemIds]) => {\n        const container = document.querySelector(`[data-container-id=\"${containerId}\"], #${containerId}`);\n        if (!container)\n            return;\n        // Create a map of current items by their IDs for quick lookup\n        const currentItems = new Map();\n        const items = container.querySelectorAll('[data-intersortable-item]');\n        items.forEach(item => {\n            const itemId = (config.getItemId || defaultGetItemId)(item);\n            if (itemId)\n                currentItems.set(itemId, item);\n        });\n        // Reorder items according to saved order\n        itemIds.forEach(itemId => {\n            const item = currentItems.get(itemId);\n            if (item) {\n                container.appendChild(item); // This moves the item to the end\n            }\n        });\n    });\n}\nexport function cleanupSortable() {\n    document.removeEventListener('mousedown', handleMouseDown);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n    // Clean up MutationObserver\n    cleanupMutationObserver();\n}\n"],
  "mappings": "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",
  "names": ["isDragging", "draggedElement", "draggedHandle", "clonedElement", "dragHandleOffset", "draggedItemCenter", "targetedItem", "insertionPosition", "lastTargetedItem", "lastInsertionPosition", "config", "mutationObserver", "calculateDistance", "point1", "point2", "getElementCenter", "element", "rect", "setupClone", "clone", "item", "mouseX", "mouseY", "handleOffset", "resetDragState", "handle", "moveItemToInsertionPoint", "itemToMove", "targetItem", "position", "originalFromContainer", "defaultGetContainerId", "targetToContainer", "itemId", "defaultGetItemId", "affectedItems", "movingItemRect", "targetParent", "nextSibling", "allContainers", "getCurrentSortOrder", "newIndex", "newMovingItemRect", "deltaX", "deltaY", "duration", "easing", "newRect", "calculateTargeting", "allItems", "nearestTarget", "nearestDistance", "itemCenter", "distance", "container", "containerCenter", "nearestItem", "targetCenter", "containers", "sortOrder", "containerId", "items", "id", "applyCursorStyles", "applyCursorStyleToItem", "handleMutations", "mutations", "mutation", "node", "setupMutationObserver", "cleanupMutationObserver", "userConfig", "handleMouseDown", "handleMouseMove", "handleMouseUp", "e", "target", "dragHandle", "itemRect", "otherItem", "cloneX", "cloneY", "_e", "savedOrder", "itemIds", "currentItems"]
}

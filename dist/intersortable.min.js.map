{
  "version": 3,
  "sources": ["intersortable.js"],
  "sourcesContent": ["// intersortable.ts - Novel approach to sortable lists between containers\n// Global state\nlet isDragging = false;\nlet draggedElement = null;\nlet draggedHandle = null;\nlet clonedElement = null;\nconst dragHandleOffset = { x: 0, y: 0 };\nlet draggedItemCenter = { x: 0, y: 0 };\nlet targetedItem = null;\nlet insertionPosition = 'above';\nlet lastTargetedItem = null;\nlet lastInsertionPosition = 'above';\n// Configuration\nlet config = {};\n// Helper functions\nfunction calculateDistance(point1, point2) {\n    return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n}\nfunction getElementCenter(element) {\n    const rect = element.getBoundingClientRect();\n    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };\n}\nfunction setupClone(clone, item, mouseX, mouseY, handleOffset) {\n    clone.removeAttribute('data-intersortable-item');\n    // Add class for CSS targeting\n    clone.classList.add('intersortable-clone');\n    clone.setAttribute('data-intersortable-state', 'clone');\n    // Base positioning and sizing (always needed)\n    clone.style.position = 'fixed';\n    clone.style.pointerEvents = 'none';\n    clone.style.left = (mouseX - handleOffset.x) + 'px';\n    clone.style.top = (mouseY - handleOffset.y) + 'px';\n    clone.style.width = item.offsetWidth + 'px';\n    clone.style.height = item.offsetHeight + 'px';\n    // Customizable styles using CSS custom properties\n    clone.style.zIndex = 'var(--intersortable-clone-z-index, 9999)';\n    clone.style.opacity = 'var(--intersortable-clone-opacity, 1)';\n    clone.style.transform = 'scale(var(--intersortable-clone-scale, 1.05))';\n    clone.style.boxShadow = 'var(--intersortable-clone-shadow, 0 10px 25px rgba(0, 0, 0, 0.3))';\n    clone.style.transition = 'var(--intersortable-clone-transition, none)';\n}\nfunction resetDragState() {\n    isDragging = false;\n    document.body.style.cursor = 'var(--intersortable-cursor-default, auto)';\n    targetedItem = null;\n    lastTargetedItem = null;\n    lastInsertionPosition = 'above';\n    // Clean up any transition styles left on items and restore pointer events\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        // Remove dragging classes and attributes\n        item.classList.remove('intersortable-dragging');\n        item.removeAttribute('data-intersortable-state');\n        // Restore pointer events\n        item.style.pointerEvents = '';\n        // Also restore pointer events on drag handles\n        const handles = item.querySelectorAll('[data-drag-handle]');\n        handles.forEach(handle => {\n            handle.style.pointerEvents = '';\n        });\n        setTimeout(() => {\n            item.style.transition = '';\n            item.style.transform = '';\n        }, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '250')); // Use CSS custom property or default\n    });\n}\n// Function to move an item to the insertion point with smooth animations\nfunction moveItemToInsertionPoint(itemToMove, targetItem, position) {\n    // FLIP technique: First - capture current positions of all affected items\n    const affectedItems = [];\n    // Find all sortable items that might be affected by this move\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    allItems.forEach(item => {\n        if (item !== itemToMove) { // Don't track the dragged item itself\n            affectedItems.push({\n                element: item,\n                rect: item.getBoundingClientRect()\n            });\n        }\n    });\n    // Capture the moving item's current position\n    const movingItemRect = itemToMove.getBoundingClientRect();\n    // Remove the item from its current position\n    if (itemToMove.parentNode) {\n        itemToMove.parentNode.removeChild(itemToMove);\n    }\n    // Check if target is an empty container (data-intersortable-container attribute)\n    if (targetItem.hasAttribute('data-intersortable-container')) {\n        // Empty container - just append the item to it\n        targetItem.appendChild(itemToMove);\n    }\n    else {\n        // Normal item-to-item insertion\n        const targetParent = targetItem.parentNode;\n        if (!targetParent)\n            return;\n        // Insert directly relative to the target item\n        if (position === 'above') {\n            targetParent.insertBefore(itemToMove, targetItem);\n        }\n        else {\n            // Insert after the target item\n            const nextSibling = targetItem.nextSibling;\n            if (nextSibling) {\n                targetParent.insertBefore(itemToMove, nextSibling);\n            }\n            else {\n                targetParent.appendChild(itemToMove);\n            }\n        }\n    }\n    // FLIP technique: Last - get new positions, Invert - calculate differences, Play - animate\n    const newMovingItemRect = itemToMove.getBoundingClientRect();\n    // Animate the moving item from its old position to new position\n    const deltaX = movingItemRect.left - newMovingItemRect.left;\n    const deltaY = movingItemRect.top - newMovingItemRect.top;\n    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n        itemToMove.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n        itemToMove.style.transition = 'none';\n        requestAnimationFrame(() => {\n            const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-duration') || '0.2s';\n            const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n            itemToMove.style.transition = `transform ${duration} ${easing}`;\n            itemToMove.style.transform = 'translate(0, 0)';\n        });\n    }\n    // Animate displaced items\n    affectedItems.forEach(({ element, rect }) => {\n        const newRect = element.getBoundingClientRect();\n        const deltaX = rect.left - newRect.left;\n        const deltaY = rect.top - newRect.top;\n        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {\n            element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n            element.style.transition = 'none';\n            requestAnimationFrame(() => {\n                const duration = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-displaced-duration') || '0.15s';\n                const easing = getComputedStyle(document.documentElement).getPropertyValue('--intersortable-animation-easing') || 'ease-out';\n                element.style.transition = `transform ${duration} ${easing}`;\n                element.style.transform = 'translate(0, 0)';\n            });\n        }\n    });\n}\n// Calculate targeting for real-time item movement\nfunction calculateTargeting() {\n    // Calculate dragged item center position\n    if (clonedElement) {\n        draggedItemCenter = getElementCenter(clonedElement);\n    }\n    // Find all sortable items and calculate distances\n    const allItems = document.querySelectorAll('[data-intersortable-item]');\n    let nearestTarget = null;\n    let nearestDistance = Infinity;\n    // Check all sortable items\n    allItems.forEach(item => {\n        const itemCenter = getElementCenter(item);\n        const distance = calculateDistance(itemCenter, draggedItemCenter);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestTarget = item;\n        }\n    });\n    // Also check empty containers\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    containers.forEach(container => {\n        const sortableItems = container.querySelectorAll('[data-intersortable-item]');\n        if (sortableItems.length === 0) { // Empty container\n            const containerCenter = getElementCenter(container);\n            const distance = calculateDistance(containerCenter, draggedItemCenter);\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                nearestTarget = container;\n            }\n        }\n    });\n    const nearestItem = nearestTarget;\n    targetedItem = nearestItem;\n    // Calculate insertion position based on dragged item center vs nearest item center\n    if (nearestItem) {\n        if (nearestItem === draggedElement) {\n            // Targeting self - no change needed\n            insertionPosition = 'above';\n        }\n        else {\n            const targetCenter = getElementCenter(nearestItem);\n            insertionPosition = draggedItemCenter.y <= targetCenter.y ? 'above' : 'below';\n        }\n    }\n    // Move the original dragged element to the insertion point in real-time\n    // Only move if the target or position has changed\n    if (nearestItem && draggedElement && nearestItem !== draggedElement) {\n        if (nearestItem !== lastTargetedItem || insertionPosition !== lastInsertionPosition) {\n            const oldContainerId = (config.getContainerId || defaultGetContainerId)(draggedElement);\n            moveItemToInsertionPoint(draggedElement, nearestItem, insertionPosition);\n            // Call onMove callback if provided\n            if (config.onMove) {\n                const itemId = (config.getItemId || defaultGetItemId)(draggedElement);\n                const newContainerId = (config.getContainerId || defaultGetContainerId)(draggedElement);\n                const allContainers = getCurrentSortOrder();\n                const newIndex = allContainers[newContainerId]?.indexOf(itemId) ?? -1;\n                if (itemId && oldContainerId && newContainerId) {\n                    config.onMove({\n                        itemId,\n                        fromContainer: oldContainerId,\n                        toContainer: newContainerId,\n                        newIndex,\n                        allContainers\n                    });\n                }\n            }\n            lastTargetedItem = nearestItem;\n            lastInsertionPosition = insertionPosition;\n        }\n    }\n}\n// Default helper functions\nfunction defaultGetItemId(element) {\n    return element.dataset.itemId || element.id || '';\n}\nfunction defaultGetContainerId(element) {\n    const container = element.closest('[data-intersortable-container]');\n    return container?.dataset.containerId || container?.id || '';\n}\n// Helper function to get current sort order\nfunction getCurrentSortOrder() {\n    const containers = document.querySelectorAll('[data-intersortable-container]');\n    const sortOrder = {};\n    containers.forEach(container => {\n        const containerId = (config.getContainerId || defaultGetContainerId)(container);\n        if (containerId) {\n            const items = container.querySelectorAll('[data-intersortable-item]');\n            sortOrder[containerId] = Array.from(items).map(item => (config.getItemId || defaultGetItemId)(item)).filter(id => id); // Filter out empty IDs\n        }\n    });\n    return sortOrder;\n}\nfunction applyCursorStyles() {\n    // Apply default grab cursor to all intersortable items\n    const items = document.querySelectorAll('[data-intersortable-item]');\n    items.forEach(item => {\n        // Check if item has a drag handle\n        const hasHandle = item.querySelector('[data-drag-handle]');\n        if (hasHandle) {\n            // Item has handle - only the handle should be grabbable\n            const handles = item.querySelectorAll('[data-drag-handle]');\n            handles.forEach(handle => {\n                if (!handle.style.cursor) {\n                    handle.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n                }\n            });\n        }\n        else {\n            // No handle - entire item is grabbable\n            if (!item.style.cursor) {\n                item.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n            }\n        }\n    });\n}\nexport function initSortable(userConfig = {}) {\n    config = { ...userConfig };\n    // Apply default cursor styles to intersortable items\n    applyCursorStyles();\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n}\nfunction handleMouseDown(e) {\n    const target = e.target;\n    let dragHandle = null;\n    let item = null;\n    // First, check if clicked element is or contains a drag handle\n    if (target.closest('[data-drag-handle]')) {\n        dragHandle = target.closest('[data-drag-handle]');\n        item = dragHandle.closest('[data-intersortable-item]');\n    }\n    else {\n        // No drag handle found, check if we clicked directly on a sortable item\n        item = target.closest('[data-intersortable-item]');\n        if (item) {\n            // Check if this item has a drag handle - if so, ignore clicks outside the handle\n            const hasHandle = item.querySelector('[data-drag-handle]');\n            if (hasHandle) {\n                return; // Item has a handle but we didn't click on it, so don't start drag\n            }\n            // No handle exists, so the entire item is draggable\n            dragHandle = item;\n        }\n    }\n    if (item && dragHandle) {\n        isDragging = true;\n        draggedElement = item;\n        draggedHandle = dragHandle;\n        // Reset tracking variables for real-time movement\n        lastTargetedItem = null;\n        lastInsertionPosition = 'above';\n        // Calculate drag handle offset - always preserve click position\n        const itemRect = item.getBoundingClientRect();\n        dragHandleOffset.x = e.clientX - itemRect.left;\n        dragHandleOffset.y = e.clientY - itemRect.top;\n        // Create clone\n        clonedElement = item.cloneNode(true);\n        setupClone(clonedElement, item, e.clientX, e.clientY, dragHandleOffset);\n        document.body.appendChild(clonedElement);\n        // Calculate initial targeting\n        calculateTargeting();\n        // Add dragging state\n        item.classList.add('intersortable-dragging');\n        item.setAttribute('data-intersortable-state', 'dragging');\n        // Apply dragging styles with CSS custom properties\n        item.style.opacity = 'var(--intersortable-dragging-opacity, 0.4)';\n        // Set cursor to grabbing on body and the specific draggable element\n        document.body.style.cursor = 'var(--intersortable-cursor-grabbing, grabbing)';\n        dragHandle.style.cursor = 'var(--intersortable-cursor-grabbing, grabbing)';\n        // Disable pointer events on all other intersortable items to prevent cursor conflicts\n        const allItems = document.querySelectorAll('[data-intersortable-item]');\n        allItems.forEach(otherItem => {\n            if (otherItem !== item) {\n                otherItem.style.pointerEvents = 'none';\n                // Also disable pointer events on their drag handles\n                const otherHandles = otherItem.querySelectorAll('[data-drag-handle]');\n                otherHandles.forEach(handle => {\n                    handle.style.pointerEvents = 'none';\n                });\n            }\n        });\n        e.preventDefault();\n    }\n}\nfunction handleMouseMove(e) {\n    if (isDragging && clonedElement) {\n        // Move clone so drag handle follows cursor\n        const cloneX = e.clientX - dragHandleOffset.x;\n        const cloneY = e.clientY - dragHandleOffset.y;\n        clonedElement.style.left = cloneX + 'px';\n        clonedElement.style.top = cloneY + 'px';\n        // Update targeting calculations\n        calculateTargeting();\n    }\n}\nfunction handleMouseUp(_e) {\n    if (isDragging) {\n        // Call onComplete callback before cleanup\n        if (config.onComplete) {\n            const allContainers = getCurrentSortOrder();\n            config.onComplete(allContainers);\n        }\n        // Cleanup\n        if (clonedElement) {\n            clonedElement.classList.remove('intersortable-clone');\n            clonedElement.removeAttribute('data-intersortable-state');\n            document.body.removeChild(clonedElement);\n            clonedElement = null;\n        }\n        if (draggedElement) {\n            draggedElement.style.opacity = '1';\n            draggedElement.classList.remove('intersortable-dragging');\n            draggedElement.removeAttribute('data-intersortable-state');\n            draggedElement = null;\n        }\n        if (draggedHandle) {\n            // Reset cursor on the specific handle that was dragged\n            draggedHandle.style.cursor = 'var(--intersortable-cursor-grab, grab)';\n            draggedHandle = null;\n        }\n        resetDragState();\n    }\n}\nexport function restoreSortOrder(savedOrder) {\n    Object.entries(savedOrder).forEach(([containerId, itemIds]) => {\n        const container = document.querySelector(`[data-container-id=\"${containerId}\"], #${containerId}`);\n        if (!container)\n            return;\n        // Create a map of current items by their IDs for quick lookup\n        const currentItems = new Map();\n        const items = container.querySelectorAll('[data-intersortable-item]');\n        items.forEach(item => {\n            const itemId = (config.getItemId || defaultGetItemId)(item);\n            if (itemId)\n                currentItems.set(itemId, item);\n        });\n        // Reorder items according to saved order\n        itemIds.forEach(itemId => {\n            const item = currentItems.get(itemId);\n            if (item) {\n                container.appendChild(item); // This moves the item to the end\n            }\n        });\n    });\n}\nexport function cleanupSortable() {\n    document.removeEventListener('mousedown', handleMouseDown);\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n}\n"],
  "mappings": "aAEA,IAAIA,EAAa,GACbC,EAAiB,KACjBC,EAAgB,KAChBC,EAAgB,KACpB,MAAMC,EAAmB,CAAE,EAAG,EAAG,EAAG,CAAE,EACtC,IAAIC,EAAoB,CAAE,EAAG,EAAG,EAAG,CAAE,EACjCC,EAAe,KACfC,EAAoB,QACpBC,EAAmB,KACnBC,EAAwB,QAExBC,EAAS,CAAC,EAEd,SAASC,EAAkBC,EAAQC,EAAQ,CACvC,OAAO,KAAK,KAAK,KAAK,IAAID,EAAO,EAAIC,EAAO,EAAG,CAAC,EAAI,KAAK,IAAID,EAAO,EAAIC,EAAO,EAAG,CAAC,CAAC,CACxF,CACA,SAASC,EAAiBC,EAAS,CAC/B,MAAMC,EAAOD,EAAQ,sBAAsB,EAC3C,MAAO,CAAE,EAAGC,EAAK,KAAOA,EAAK,MAAQ,EAAG,EAAGA,EAAK,IAAMA,EAAK,OAAS,CAAE,CAC1E,CACA,SAASC,EAAWC,EAAOC,EAAMC,EAAQC,EAAQC,EAAc,CAC3DJ,EAAM,gBAAgB,yBAAyB,EAE/CA,EAAM,UAAU,IAAI,qBAAqB,EACzCA,EAAM,aAAa,2BAA4B,OAAO,EAEtDA,EAAM,MAAM,SAAW,QACvBA,EAAM,MAAM,cAAgB,OAC5BA,EAAM,MAAM,KAAQE,EAASE,EAAa,EAAK,KAC/CJ,EAAM,MAAM,IAAOG,EAASC,EAAa,EAAK,KAC9CJ,EAAM,MAAM,MAAQC,EAAK,YAAc,KACvCD,EAAM,MAAM,OAASC,EAAK,aAAe,KAEzCD,EAAM,MAAM,OAAS,2CACrBA,EAAM,MAAM,QAAU,wCACtBA,EAAM,MAAM,UAAY,gDACxBA,EAAM,MAAM,UAAY,oEACxBA,EAAM,MAAM,WAAa,6CAC7B,CACA,SAASK,GAAiB,CACtBvB,EAAa,GACb,SAAS,KAAK,MAAM,OAAS,4CAC7BM,EAAe,KACfE,EAAmB,KACnBC,EAAwB,QAEP,SAAS,iBAAiB,2BAA2B,EAC7D,QAAQU,GAAQ,CAErBA,EAAK,UAAU,OAAO,wBAAwB,EAC9CA,EAAK,gBAAgB,0BAA0B,EAE/CA,EAAK,MAAM,cAAgB,GAEXA,EAAK,iBAAiB,oBAAoB,EAClD,QAAQK,GAAU,CACtBA,EAAO,MAAM,cAAgB,EACjC,CAAC,EACD,WAAW,IAAM,CACbL,EAAK,MAAM,WAAa,GACxBA,EAAK,MAAM,UAAY,EAC3B,EAAG,WAAW,iBAAiB,SAAS,eAAe,EAAE,iBAAiB,oCAAoC,GAAK,KAAK,CAAC,CAC7H,CAAC,CACL,CAEA,SAASM,EAAyBC,EAAYC,EAAYC,EAAU,CAEhE,MAAMC,EAAgB,CAAC,EAEN,SAAS,iBAAiB,2BAA2B,EAC7D,QAAQV,GAAQ,CACjBA,IAASO,GACTG,EAAc,KAAK,CACf,QAASV,EACT,KAAMA,EAAK,sBAAsB,CACrC,CAAC,CAET,CAAC,EAED,MAAMW,EAAiBJ,EAAW,sBAAsB,EAMxD,GAJIA,EAAW,YACXA,EAAW,WAAW,YAAYA,CAAU,EAG5CC,EAAW,aAAa,8BAA8B,EAEtDA,EAAW,YAAYD,CAAU,MAEhC,CAED,MAAMK,EAAeJ,EAAW,WAChC,GAAI,CAACI,EACD,OAEJ,GAAIH,IAAa,QACbG,EAAa,aAAaL,EAAYC,CAAU,MAE/C,CAED,MAAMK,EAAcL,EAAW,YAC3BK,EACAD,EAAa,aAAaL,EAAYM,CAAW,EAGjDD,EAAa,YAAYL,CAAU,CAE3C,CACJ,CAEA,MAAMO,EAAoBP,EAAW,sBAAsB,EAErDQ,EAASJ,EAAe,KAAOG,EAAkB,KACjDE,EAASL,EAAe,IAAMG,EAAkB,KAClD,KAAK,IAAIC,CAAM,EAAI,GAAK,KAAK,IAAIC,CAAM,EAAI,KAC3CT,EAAW,MAAM,UAAY,aAAaQ,CAAM,OAAOC,CAAM,MAC7DT,EAAW,MAAM,WAAa,OAC9B,sBAAsB,IAAM,CACxB,MAAMU,EAAW,iBAAiB,SAAS,eAAe,EAAE,iBAAiB,oCAAoC,GAAK,OAChHC,EAAS,iBAAiB,SAAS,eAAe,EAAE,iBAAiB,kCAAkC,GAAK,WAClHX,EAAW,MAAM,WAAa,aAAaU,CAAQ,IAAIC,CAAM,GAC7DX,EAAW,MAAM,UAAY,iBACjC,CAAC,GAGLG,EAAc,QAAQ,CAAC,CAAE,QAAAd,EAAS,KAAAC,CAAK,IAAM,CACzC,MAAMsB,EAAUvB,EAAQ,sBAAsB,EACxCmB,EAASlB,EAAK,KAAOsB,EAAQ,KAC7BH,EAASnB,EAAK,IAAMsB,EAAQ,KAC9B,KAAK,IAAIJ,CAAM,EAAI,GAAK,KAAK,IAAIC,CAAM,EAAI,KAC3CpB,EAAQ,MAAM,UAAY,aAAamB,CAAM,OAAOC,CAAM,MAC1DpB,EAAQ,MAAM,WAAa,OAC3B,sBAAsB,IAAM,CACxB,MAAMqB,EAAW,iBAAiB,SAAS,eAAe,EAAE,iBAAiB,oCAAoC,GAAK,QAChHC,EAAS,iBAAiB,SAAS,eAAe,EAAE,iBAAiB,kCAAkC,GAAK,WAClHtB,EAAQ,MAAM,WAAa,aAAaqB,CAAQ,IAAIC,CAAM,GAC1DtB,EAAQ,MAAM,UAAY,iBAC9B,CAAC,EAET,CAAC,CACL,CAEA,SAASwB,GAAqB,CAEtBpC,IACAE,EAAoBS,EAAiBX,CAAa,GAGtD,MAAMqC,EAAW,SAAS,iBAAiB,2BAA2B,EACtE,IAAIC,EAAgB,KAChBC,EAAkB,IAEtBF,EAAS,QAAQrB,GAAQ,CACrB,MAAMwB,EAAa7B,EAAiBK,CAAI,EAClCyB,EAAWjC,EAAkBgC,EAAYtC,CAAiB,EAC5DuC,EAAWF,IACXA,EAAkBE,EAClBH,EAAgBtB,EAExB,CAAC,EAEkB,SAAS,iBAAiB,gCAAgC,EAClE,QAAQ0B,GAAa,CAE5B,GADsBA,EAAU,iBAAiB,2BAA2B,EAC1D,SAAW,EAAG,CAC5B,MAAMC,EAAkBhC,EAAiB+B,CAAS,EAC5CD,EAAWjC,EAAkBmC,EAAiBzC,CAAiB,EACjEuC,EAAWF,IACXA,EAAkBE,EAClBH,EAAgBI,EAExB,CACJ,CAAC,EACD,MAAME,EAAcN,EAGpB,GAFAnC,EAAeyC,EAEXA,EACA,GAAIA,IAAgB9C,EAEhBM,EAAoB,YAEnB,CACD,MAAMyC,EAAelC,EAAiBiC,CAAW,EACjDxC,EAAoBF,EAAkB,GAAK2C,EAAa,EAAI,QAAU,OAC1E,CAIJ,GAAID,GAAe9C,GAAkB8C,IAAgB9C,IAC7C8C,IAAgBvC,GAAoBD,IAAsBE,GAAuB,CACjF,MAAMwC,GAAkBvC,EAAO,gBAAkBwC,GAAuBjD,CAAc,EAGtF,GAFAwB,EAAyBxB,EAAgB8C,EAAaxC,CAAiB,EAEnEG,EAAO,OAAQ,CACf,MAAMyC,GAAUzC,EAAO,WAAa0C,GAAkBnD,CAAc,EAC9DoD,GAAkB3C,EAAO,gBAAkBwC,GAAuBjD,CAAc,EAChFqD,EAAgBC,EAAoB,EACpCC,EAAWF,EAAcD,CAAc,GAAG,QAAQF,CAAM,GAAK,GAC/DA,GAAUF,GAAkBI,GAC5B3C,EAAO,OAAO,CACV,OAAAyC,EACA,cAAeF,EACf,YAAaI,EACb,SAAAG,EACA,cAAAF,CACJ,CAAC,CAET,CACA9C,EAAmBuC,EACnBtC,EAAwBF,CAC5B,CAER,CAEA,SAAS6C,EAAiBrC,EAAS,CAC/B,OAAOA,EAAQ,QAAQ,QAAUA,EAAQ,IAAM,EACnD,CACA,SAASmC,EAAsBnC,EAAS,CACpC,MAAM8B,EAAY9B,EAAQ,QAAQ,gCAAgC,EAClE,OAAO8B,GAAW,QAAQ,aAAeA,GAAW,IAAM,EAC9D,CAEA,SAASU,GAAsB,CAC3B,MAAME,EAAa,SAAS,iBAAiB,gCAAgC,EACvEC,EAAY,CAAC,EACnB,OAAAD,EAAW,QAAQZ,GAAa,CAC5B,MAAMc,GAAejD,EAAO,gBAAkBwC,GAAuBL,CAAS,EAC9E,GAAIc,EAAa,CACb,MAAMC,EAAQf,EAAU,iBAAiB,2BAA2B,EACpEa,EAAUC,CAAW,EAAI,MAAM,KAAKC,CAAK,EAAE,IAAIzC,IAAST,EAAO,WAAa0C,GAAkBjC,CAAI,CAAC,EAAE,OAAO0C,GAAMA,CAAE,CACxH,CACJ,CAAC,EACMH,CACX,CACA,SAASI,GAAoB,CAEX,SAAS,iBAAiB,2BAA2B,EAC7D,QAAQ3C,GAAQ,CAEAA,EAAK,cAAc,oBAAoB,EAGrCA,EAAK,iBAAiB,oBAAoB,EAClD,QAAQK,GAAU,CACjBA,EAAO,MAAM,SACdA,EAAO,MAAM,OAAS,yCAE9B,CAAC,EAIIL,EAAK,MAAM,SACZA,EAAK,MAAM,OAAS,yCAGhC,CAAC,CACL,CACO,gBAAS,aAAa4C,EAAa,CAAC,EAAG,CAC1CrD,EAAS,CAAE,GAAGqD,CAAW,EAEzBD,EAAkB,EAClB,SAAS,iBAAiB,YAAaE,CAAe,EACtD,SAAS,iBAAiB,YAAaC,CAAe,EACtD,SAAS,iBAAiB,UAAWC,CAAa,CACtD,CACA,SAASF,EAAgBG,EAAG,CACxB,MAAMC,EAASD,EAAE,OACjB,IAAIE,EAAa,KACblD,EAAO,KAEX,GAAIiD,EAAO,QAAQ,oBAAoB,EACnCC,EAAaD,EAAO,QAAQ,oBAAoB,EAChDjD,EAAOkD,EAAW,QAAQ,2BAA2B,UAIrDlD,EAAOiD,EAAO,QAAQ,2BAA2B,EAC7CjD,EAAM,CAGN,GADkBA,EAAK,cAAc,oBAAoB,EAErD,OAGJkD,EAAalD,CACjB,CAEJ,GAAIA,GAAQkD,EAAY,CACpBrE,EAAa,GACbC,EAAiBkB,EACjBjB,EAAgBmE,EAEhB7D,EAAmB,KACnBC,EAAwB,QAExB,MAAM6D,EAAWnD,EAAK,sBAAsB,EAC5Cf,EAAiB,EAAI+D,EAAE,QAAUG,EAAS,KAC1ClE,EAAiB,EAAI+D,EAAE,QAAUG,EAAS,IAE1CnE,EAAgBgB,EAAK,UAAU,EAAI,EACnCF,EAAWd,EAAegB,EAAMgD,EAAE,QAASA,EAAE,QAAS/D,CAAgB,EACtE,SAAS,KAAK,YAAYD,CAAa,EAEvCoC,EAAmB,EAEnBpB,EAAK,UAAU,IAAI,wBAAwB,EAC3CA,EAAK,aAAa,2BAA4B,UAAU,EAExDA,EAAK,MAAM,QAAU,6CAErB,SAAS,KAAK,MAAM,OAAS,iDAC7BkD,EAAW,MAAM,OAAS,iDAET,SAAS,iBAAiB,2BAA2B,EAC7D,QAAQE,GAAa,CACtBA,IAAcpD,IACdoD,EAAU,MAAM,cAAgB,OAEXA,EAAU,iBAAiB,oBAAoB,EACvD,QAAQ/C,GAAU,CAC3BA,EAAO,MAAM,cAAgB,MACjC,CAAC,EAET,CAAC,EACD2C,EAAE,eAAe,CACrB,CACJ,CACA,SAASF,EAAgBE,EAAG,CACxB,GAAInE,GAAcG,EAAe,CAE7B,MAAMqE,EAASL,EAAE,QAAU/D,EAAiB,EACtCqE,EAASN,EAAE,QAAU/D,EAAiB,EAC5CD,EAAc,MAAM,KAAOqE,EAAS,KACpCrE,EAAc,MAAM,IAAMsE,EAAS,KAEnClC,EAAmB,CACvB,CACJ,CACA,SAAS2B,EAAcQ,EAAI,CACvB,GAAI1E,EAAY,CAEZ,GAAIU,EAAO,WAAY,CACnB,MAAM4C,EAAgBC,EAAoB,EAC1C7C,EAAO,WAAW4C,CAAa,CACnC,CAEInD,IACAA,EAAc,UAAU,OAAO,qBAAqB,EACpDA,EAAc,gBAAgB,0BAA0B,EACxD,SAAS,KAAK,YAAYA,CAAa,EACvCA,EAAgB,MAEhBF,IACAA,EAAe,MAAM,QAAU,IAC/BA,EAAe,UAAU,OAAO,wBAAwB,EACxDA,EAAe,gBAAgB,0BAA0B,EACzDA,EAAiB,MAEjBC,IAEAA,EAAc,MAAM,OAAS,yCAC7BA,EAAgB,MAEpBqB,EAAe,CACnB,CACJ,CACO,gBAAS,iBAAiBoD,EAAY,CACzC,OAAO,QAAQA,CAAU,EAAE,QAAQ,CAAC,CAAChB,EAAaiB,CAAO,IAAM,CAC3D,MAAM/B,EAAY,SAAS,cAAc,uBAAuBc,CAAW,QAAQA,CAAW,EAAE,EAChG,GAAI,CAACd,EACD,OAEJ,MAAMgC,EAAe,IAAI,IACXhC,EAAU,iBAAiB,2BAA2B,EAC9D,QAAQ1B,GAAQ,CAClB,MAAMgC,GAAUzC,EAAO,WAAa0C,GAAkBjC,CAAI,EACtDgC,GACA0B,EAAa,IAAI1B,EAAQhC,CAAI,CACrC,CAAC,EAEDyD,EAAQ,QAAQzB,GAAU,CACtB,MAAMhC,EAAO0D,EAAa,IAAI1B,CAAM,EAChChC,GACA0B,EAAU,YAAY1B,CAAI,CAElC,CAAC,CACL,CAAC,CACL,CACO,gBAAS,iBAAkB,CAC9B,SAAS,oBAAoB,YAAa6C,CAAe,EACzD,SAAS,oBAAoB,YAAaC,CAAe,EACzD,SAAS,oBAAoB,UAAWC,CAAa,CACzD",
  "names": ["isDragging", "draggedElement", "draggedHandle", "clonedElement", "dragHandleOffset", "draggedItemCenter", "targetedItem", "insertionPosition", "lastTargetedItem", "lastInsertionPosition", "config", "calculateDistance", "point1", "point2", "getElementCenter", "element", "rect", "setupClone", "clone", "item", "mouseX", "mouseY", "handleOffset", "resetDragState", "handle", "moveItemToInsertionPoint", "itemToMove", "targetItem", "position", "affectedItems", "movingItemRect", "targetParent", "nextSibling", "newMovingItemRect", "deltaX", "deltaY", "duration", "easing", "newRect", "calculateTargeting", "allItems", "nearestTarget", "nearestDistance", "itemCenter", "distance", "container", "containerCenter", "nearestItem", "targetCenter", "oldContainerId", "defaultGetContainerId", "itemId", "defaultGetItemId", "newContainerId", "allContainers", "getCurrentSortOrder", "newIndex", "containers", "sortOrder", "containerId", "items", "id", "applyCursorStyles", "userConfig", "handleMouseDown", "handleMouseMove", "handleMouseUp", "e", "target", "dragHandle", "itemRect", "otherItem", "cloneX", "cloneY", "_e", "savedOrder", "itemIds", "currentItems"]
}

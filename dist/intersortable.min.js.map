{
  "version": 3,
  "sources": ["intersortable.js"],
  "sourcesContent": ["// intersortable.ts - Clean slate rework\nclass Intersortable {\n    constructor(callbacks) {\n        this.dragState = {\n            isDragging: false,\n            originalItem: null,\n            cloneItem: null,\n            startX: 0,\n            startY: 0,\n            nearestItem: null,\n            lastTargetedElement: null,\n            ghostItems: [],\n            animatingElements: new Set()\n        };\n        this.callbacks = {};\n        if (callbacks) {\n            this.callbacks = callbacks;\n        }\n        this.init();\n    }\n    init() {\n        this.injectStyles();\n        document.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        document.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        document.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    }\n    injectStyles() {\n        // Check if styles are already injected\n        if (document.getElementById('intersortable-styles')) {\n            return;\n        }\n        const styleElement = document.createElement('style');\n        styleElement.id = 'intersortable-styles';\n        styleElement.textContent = `\n      /* Default cursor styles for intersortable items */\n      [data-intersortable-item-id]:hover {\n        cursor: grab !important;\n      }\n\n      /* When item has a drag handle, remove cursor from entire item */\n      [data-intersortable-item-id]:has([data-intersortable-drag-handle]):hover {\n        cursor: default !important;\n      }\n\n      /* Drag handle specific cursor states */\n      [data-intersortable-drag-handle]:hover {\n        cursor: grab !important;\n      }\n\n      /* Force grabbing cursor everywhere during drag */\n      body.intersortable-dragging,\n      body.intersortable-dragging *,\n      body.intersortable-dragging [data-intersortable-item-id]:hover,\n      body.intersortable-dragging [data-intersortable-drag-handle]:hover {\n        cursor: grabbing !important;\n      }\n    `;\n        document.head.appendChild(styleElement);\n    }\n    handleMouseDown(event) {\n        const target = event.target;\n        const item = target.closest('[data-intersortable-item-id]');\n        if (!item)\n            return;\n        // Check if item has a drag handle\n        const dragHandle = item.querySelector('[data-intersortable-drag-handle]');\n        if (dragHandle) {\n            // If drag handle exists, only allow dragging from the handle\n            const clickedHandle = target.closest('[data-intersortable-drag-handle]');\n            if (!clickedHandle)\n                return; // Clicked outside handle, don't start drag\n        }\n        // If no drag handle, entire item is draggable (existing behavior)\n        event.preventDefault();\n        this.dragState.isDragging = true;\n        this.dragState.originalItem = item;\n        this.dragState.startX = event.clientX;\n        this.dragState.startY = event.clientY;\n        // Set grabbing cursor for entire document while dragging\n        document.body.classList.add('intersortable-dragging');\n        // Set original item to 40% opacity\n        item.style.opacity = '0.4';\n        // Create clone\n        this.createClone(item, event.clientX, event.clientY);\n        // Initialize targeting system\n        this.initializeTargetingSystem();\n        // Trigger onPickup callback\n        if (this.callbacks.onPickup) {\n            this.callbacks.onPickup(this.getCurrentState());\n        }\n    }\n    createClone(originalItem, x, y) {\n        const clone = originalItem.cloneNode(true);\n        const rect = originalItem.getBoundingClientRect();\n        // Style the clone\n        clone.style.position = 'fixed';\n        clone.style.left = `${rect.left}px`;\n        clone.style.top = `${rect.top}px`;\n        clone.style.width = `${rect.width}px`;\n        clone.style.height = `${rect.height}px`;\n        clone.style.transform = 'scale(1.05)';\n        clone.style.transformOrigin = 'center';\n        clone.style.pointerEvents = 'none';\n        clone.style.zIndex = '1000';\n        clone.style.opacity = '1';\n        // Add style hook class\n        clone.classList.add('intersortable-drag-clone');\n        // Remove the data attribute to avoid conflicts\n        clone.removeAttribute('data-intersortable-item-id');\n        document.body.appendChild(clone);\n        this.dragState.cloneItem = clone;\n    }\n    handleMouseMove(event) {\n        if (!this.dragState.isDragging || !this.dragState.cloneItem)\n            return;\n        const deltaX = event.clientX - this.dragState.startX;\n        const deltaY = event.clientY - this.dragState.startY;\n        // Keep clone attached to cursor based on initial position\n        const rect = this.dragState.cloneItem.getBoundingClientRect();\n        const initialLeft = parseFloat(this.dragState.cloneItem.style.left);\n        const initialTop = parseFloat(this.dragState.cloneItem.style.top);\n        this.dragState.cloneItem.style.left = `${initialLeft + deltaX}px`;\n        this.dragState.cloneItem.style.top = `${initialTop + deltaY}px`;\n        // Update start position for next movement calculation\n        this.dragState.startX = event.clientX;\n        this.dragState.startY = event.clientY;\n        // Update targeting system\n        this.updateTargetingSystem();\n    }\n    handleMouseUp(event) {\n        if (!this.dragState.isDragging)\n            return;\n        // Reset cursor to default\n        document.body.classList.remove('intersortable-dragging');\n        // Restore original item opacity\n        if (this.dragState.originalItem) {\n            this.dragState.originalItem.style.opacity = '';\n        }\n        // Remove clone\n        if (this.dragState.cloneItem) {\n            document.body.removeChild(this.dragState.cloneItem);\n        }\n        // Clean up targeting system\n        this.cleanupTargetingSystem();\n        // Clean up ghost items\n        this.cleanupGhostItems();\n        // Trigger onDrop callback\n        if (this.callbacks.onDrop) {\n            this.callbacks.onDrop(this.getCurrentState());\n        }\n        // Reset drag state\n        this.dragState = {\n            isDragging: false,\n            originalItem: null,\n            cloneItem: null,\n            startX: 0,\n            startY: 0,\n            nearestItem: null,\n            lastTargetedElement: null,\n            ghostItems: [],\n            animatingElements: new Set()\n        };\n    }\n    initializeTargetingSystem() {\n        // Get all intersortable containers\n        const allContainers = document.querySelectorAll('[data-intersortable-container-id]');\n        allContainers.forEach(container => {\n            const items = container.querySelectorAll('[data-intersortable-item-id]');\n            if (items.length === 0) {\n                // Empty container - create ghost item\n                const ghostItem = this.createGhostItem();\n                container.appendChild(ghostItem);\n                this.dragState.ghostItems.push(ghostItem);\n            }\n        });\n        this.updateTargetingSystem();\n    }\n    createGhostItem() {\n        // Create a simple ghost item\n        const ghost = document.createElement('div');\n        ghost.className = 'bg-neutral-700 rounded px-3 py-2 text-neutral-300 text-sm';\n        ghost.setAttribute('data-intersortable-item-id', `ghost-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`);\n        ghost.textContent = '\uD83D\uDC7B Drop here';\n        ghost.style.opacity = '0';\n        ghost.style.pointerEvents = 'none';\n        return ghost;\n    }\n    updateTargetingSystem() {\n        if (!this.dragState.cloneItem)\n            return;\n        const cloneRect = this.dragState.cloneItem.getBoundingClientRect();\n        const cloneCenterX = cloneRect.left + cloneRect.width / 2;\n        const cloneCenterY = cloneRect.top + cloneRect.height / 2;\n        let nearestDistance = Infinity;\n        let nearestElement = null;\n        // Get all targetable elements (items and ghosts)\n        const allItems = document.querySelectorAll('[data-intersortable-item-id]');\n        // Find nearest element by calculating distances\n        allItems.forEach(item => {\n            const itemRect = item.getBoundingClientRect();\n            const itemCenterX = itemRect.left + itemRect.width / 2;\n            const itemCenterY = itemRect.top + itemRect.height / 2;\n            const distance = Math.sqrt(Math.pow(cloneCenterX - itemCenterX, 2) +\n                Math.pow(cloneCenterY - itemCenterY, 2));\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                nearestElement = item;\n            }\n        });\n        // Update nearest item and move original item\n        if (nearestElement) {\n            this.dragState.nearestItem = nearestElement;\n            this.moveOriginalItem();\n        }\n    }\n    moveOriginalItem() {\n        if (!this.dragState.originalItem || !this.dragState.nearestItem || !this.dragState.cloneItem)\n            return;\n        const nearestElement = this.dragState.nearestItem;\n        const originalItem = this.dragState.originalItem;\n        // Check if nearest element is a ghost item\n        const isGhost = nearestElement.getAttribute('data-intersortable-item-id')?.startsWith('ghost-');\n        let needsRecreate = false;\n        let targetParent = null;\n        let insertionPoint = null;\n        if (isGhost) {\n            // Insert original item above the ghost (always before)\n            const ghostParent = nearestElement.parentNode;\n            if (ghostParent && originalItem.parentNode !== ghostParent) {\n                targetParent = ghostParent;\n                insertionPoint = nearestElement; // Always insert before the ghost\n                needsRecreate = true;\n            }\n        }\n        else {\n            // Move above or below the targeted item (normal behavior)\n            const cloneRect = this.dragState.cloneItem.getBoundingClientRect();\n            const targetRect = nearestElement.getBoundingClientRect();\n            const cloneCenterY = cloneRect.top + cloneRect.height / 2;\n            const targetCenterY = targetRect.top + targetRect.height / 2;\n            if (cloneCenterY < targetCenterY) {\n                // Clone is above target - insert before\n                if (originalItem.nextElementSibling !== nearestElement) {\n                    targetParent = nearestElement.parentNode;\n                    insertionPoint = nearestElement;\n                    needsRecreate = true;\n                }\n            }\n            else {\n                // Clone is below target - insert after\n                if (originalItem.previousElementSibling !== nearestElement) {\n                    targetParent = nearestElement.parentNode;\n                    insertionPoint = nearestElement.nextSibling;\n                    needsRecreate = true;\n                }\n            }\n        }\n        // Perform FLIP animation if we need to move\n        if (needsRecreate && targetParent && insertionPoint !== undefined) {\n            this.performFLIPAnimation(targetParent, insertionPoint);\n        }\n        // Only recreate targeting system if DOM structure actually changed\n        if (needsRecreate) {\n            this.recreateTargetingSystem();\n        }\n    }\n    performFLIPAnimation(targetParent, insertionPoint) {\n        // FIRST: Capture all current positions\n        const allItems = document.querySelectorAll('[data-intersortable-item-id]');\n        const beforePositions = new Map();\n        allItems.forEach(item => {\n            beforePositions.set(item, item.getBoundingClientRect());\n        });\n        // LAST: Make the DOM changes - always insert, never replace\n        if (insertionPoint) {\n            targetParent.insertBefore(this.dragState.originalItem, insertionPoint);\n        }\n        else {\n            targetParent.appendChild(this.dragState.originalItem);\n        }\n        // INVERT: Calculate differences and animate\n        allItems.forEach(item => {\n            const beforeRect = beforePositions.get(item);\n            if (!beforeRect)\n                return;\n            const afterRect = item.getBoundingClientRect();\n            const deltaX = beforeRect.left - afterRect.left;\n            const deltaY = beforeRect.top - afterRect.top;\n            // Only animate if there's a meaningful change\n            if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {\n                this.animateElement(item, deltaX, deltaY);\n            }\n        });\n    }\n    animateElement(element, deltaX, deltaY) {\n        // Mark element as animating\n        this.dragState.animatingElements.add(element);\n        // PLAY: Animate from old position to new position\n        const animation = element.animate([\n            { transform: `translate(${deltaX}px, ${deltaY}px)` },\n            { transform: 'translate(0, 0)' }\n        ], {\n            duration: 300,\n            easing: 'ease-out'\n        });\n        // Remove from animating set when done\n        animation.addEventListener('finish', () => {\n            this.dragState.animatingElements.delete(element);\n        });\n    }\n    recreateTargetingSystem() {\n        // Recreate ghosts for empty containers\n        const allContainers = document.querySelectorAll('[data-intersortable-container-id]');\n        allContainers.forEach(container => {\n            const items = container.querySelectorAll('[data-intersortable-item-id]');\n            if (items.length === 0) {\n                // Empty container - create ghost item\n                const ghostItem = this.createGhostItem();\n                container.appendChild(ghostItem);\n                this.dragState.ghostItems.push(ghostItem);\n            }\n        });\n    }\n    cleanupTargetingSystem() {\n        this.dragState.nearestItem = null;\n        this.dragState.lastTargetedElement = null;\n    }\n    cleanupGhostItems() {\n        this.dragState.ghostItems.forEach(ghost => {\n            if (ghost.parentNode) {\n                ghost.parentNode.removeChild(ghost);\n            }\n        });\n        this.dragState.ghostItems = [];\n    }\n    getCurrentState() {\n        const state = {};\n        const containers = document.querySelectorAll('[data-intersortable-container-id]');\n        containers.forEach(container => {\n            const containerId = container.getAttribute('data-intersortable-container-id');\n            const items = container.querySelectorAll('[data-intersortable-item-id]');\n            // Filter out ghost items by checking if they have ghost IDs or are in our ghost items array\n            const realItems = Array.from(items).filter(item => {\n                const itemId = item.getAttribute('data-intersortable-item-id') || '';\n                const isGhost = itemId.startsWith('ghost-') || this.dragState.ghostItems.includes(item);\n                return !isGhost;\n            });\n            state[containerId] = realItems.map((item, index) => ({\n                id: item.getAttribute('data-intersortable-item-id') || '',\n                text: item.textContent || '',\n                position: index\n            }));\n        });\n        return state;\n    }\n    // Static method to initialize with callbacks\n    static init(callbacks) {\n        return new Intersortable(callbacks);\n    }\n}\n// Export for manual initialization\nexport default Intersortable;\n"],
  "mappings": "aACA,MAAMA,CAAc,CAChB,YAAYC,EAAW,CACnB,KAAK,UAAY,CACb,WAAY,GACZ,aAAc,KACd,UAAW,KACX,OAAQ,EACR,OAAQ,EACR,YAAa,KACb,oBAAqB,KACrB,WAAY,CAAC,EACb,kBAAmB,IAAI,GAC3B,EACA,KAAK,UAAY,CAAC,EACdA,IACA,KAAK,UAAYA,GAErB,KAAK,KAAK,CACd,CACA,MAAO,CACH,KAAK,aAAa,EAClB,SAAS,iBAAiB,YAAa,KAAK,gBAAgB,KAAK,IAAI,CAAC,EACtE,SAAS,iBAAiB,YAAa,KAAK,gBAAgB,KAAK,IAAI,CAAC,EACtE,SAAS,iBAAiB,UAAW,KAAK,cAAc,KAAK,IAAI,CAAC,CACtE,CACA,cAAe,CAEX,GAAI,SAAS,eAAe,sBAAsB,EAC9C,OAEJ,MAAMC,EAAe,SAAS,cAAc,OAAO,EACnDA,EAAa,GAAK,uBAClBA,EAAa,YAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAwB3B,SAAS,KAAK,YAAYA,CAAY,CAC1C,CACA,gBAAgBC,EAAO,CACnB,MAAMC,EAASD,EAAM,OACfE,EAAOD,EAAO,QAAQ,8BAA8B,EACtD,CAACC,GAGcA,EAAK,cAAc,kCAAkC,GAIhE,CADkBD,EAAO,QAAQ,kCAAkC,IAK3ED,EAAM,eAAe,EACrB,KAAK,UAAU,WAAa,GAC5B,KAAK,UAAU,aAAeE,EAC9B,KAAK,UAAU,OAASF,EAAM,QAC9B,KAAK,UAAU,OAASA,EAAM,QAE9B,SAAS,KAAK,UAAU,IAAI,wBAAwB,EAEpDE,EAAK,MAAM,QAAU,MAErB,KAAK,YAAYA,EAAMF,EAAM,QAASA,EAAM,OAAO,EAEnD,KAAK,0BAA0B,EAE3B,KAAK,UAAU,UACf,KAAK,UAAU,SAAS,KAAK,gBAAgB,CAAC,EAEtD,CACA,YAAYG,EAAcC,EAAGC,EAAG,CAC5B,MAAMC,EAAQH,EAAa,UAAU,EAAI,EACnCI,EAAOJ,EAAa,sBAAsB,EAEhDG,EAAM,MAAM,SAAW,QACvBA,EAAM,MAAM,KAAO,GAAGC,EAAK,IAAI,KAC/BD,EAAM,MAAM,IAAM,GAAGC,EAAK,GAAG,KAC7BD,EAAM,MAAM,MAAQ,GAAGC,EAAK,KAAK,KACjCD,EAAM,MAAM,OAAS,GAAGC,EAAK,MAAM,KACnCD,EAAM,MAAM,UAAY,cACxBA,EAAM,MAAM,gBAAkB,SAC9BA,EAAM,MAAM,cAAgB,OAC5BA,EAAM,MAAM,OAAS,OACrBA,EAAM,MAAM,QAAU,IAEtBA,EAAM,UAAU,IAAI,0BAA0B,EAE9CA,EAAM,gBAAgB,4BAA4B,EAClD,SAAS,KAAK,YAAYA,CAAK,EAC/B,KAAK,UAAU,UAAYA,CAC/B,CACA,gBAAgBN,EAAO,CACnB,GAAI,CAAC,KAAK,UAAU,YAAc,CAAC,KAAK,UAAU,UAC9C,OACJ,MAAMQ,EAASR,EAAM,QAAU,KAAK,UAAU,OACxCS,EAAST,EAAM,QAAU,KAAK,UAAU,OAExCO,EAAO,KAAK,UAAU,UAAU,sBAAsB,EACtDG,EAAc,WAAW,KAAK,UAAU,UAAU,MAAM,IAAI,EAC5DC,EAAa,WAAW,KAAK,UAAU,UAAU,MAAM,GAAG,EAChE,KAAK,UAAU,UAAU,MAAM,KAAO,GAAGD,EAAcF,CAAM,KAC7D,KAAK,UAAU,UAAU,MAAM,IAAM,GAAGG,EAAaF,CAAM,KAE3D,KAAK,UAAU,OAAST,EAAM,QAC9B,KAAK,UAAU,OAASA,EAAM,QAE9B,KAAK,sBAAsB,CAC/B,CACA,cAAcA,EAAO,CACZ,KAAK,UAAU,aAGpB,SAAS,KAAK,UAAU,OAAO,wBAAwB,EAEnD,KAAK,UAAU,eACf,KAAK,UAAU,aAAa,MAAM,QAAU,IAG5C,KAAK,UAAU,WACf,SAAS,KAAK,YAAY,KAAK,UAAU,SAAS,EAGtD,KAAK,uBAAuB,EAE5B,KAAK,kBAAkB,EAEnB,KAAK,UAAU,QACf,KAAK,UAAU,OAAO,KAAK,gBAAgB,CAAC,EAGhD,KAAK,UAAY,CACb,WAAY,GACZ,aAAc,KACd,UAAW,KACX,OAAQ,EACR,OAAQ,EACR,YAAa,KACb,oBAAqB,KACrB,WAAY,CAAC,EACb,kBAAmB,IAAI,GAC3B,EACJ,CACA,2BAA4B,CAEF,SAAS,iBAAiB,mCAAmC,EACrE,QAAQY,GAAa,CAE/B,GADcA,EAAU,iBAAiB,8BAA8B,EAC7D,SAAW,EAAG,CAEpB,MAAMC,EAAY,KAAK,gBAAgB,EACvCD,EAAU,YAAYC,CAAS,EAC/B,KAAK,UAAU,WAAW,KAAKA,CAAS,CAC5C,CACJ,CAAC,EACD,KAAK,sBAAsB,CAC/B,CACA,iBAAkB,CAEd,MAAMC,EAAQ,SAAS,cAAc,KAAK,EAC1C,OAAAA,EAAM,UAAY,4DAClBA,EAAM,aAAa,6BAA8B,SAAS,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,EAAE,EACjHA,EAAM,YAAc,sBACpBA,EAAM,MAAM,QAAU,IACtBA,EAAM,MAAM,cAAgB,OACrBA,CACX,CACA,uBAAwB,CACpB,GAAI,CAAC,KAAK,UAAU,UAChB,OACJ,MAAMC,EAAY,KAAK,UAAU,UAAU,sBAAsB,EAC3DC,EAAeD,EAAU,KAAOA,EAAU,MAAQ,EAClDE,EAAeF,EAAU,IAAMA,EAAU,OAAS,EACxD,IAAIG,EAAkB,IAClBC,EAAiB,KAEJ,SAAS,iBAAiB,8BAA8B,EAEhE,QAAQjB,GAAQ,CACrB,MAAMkB,EAAWlB,EAAK,sBAAsB,EACtCmB,EAAcD,EAAS,KAAOA,EAAS,MAAQ,EAC/CE,EAAcF,EAAS,IAAMA,EAAS,OAAS,EAC/CG,EAAW,KAAK,KAAK,KAAK,IAAIP,EAAeK,EAAa,CAAC,EAC7D,KAAK,IAAIJ,EAAeK,EAAa,CAAC,CAAC,EACvCC,EAAWL,IACXA,EAAkBK,EAClBJ,EAAiBjB,EAEzB,CAAC,EAEGiB,IACA,KAAK,UAAU,YAAcA,EAC7B,KAAK,iBAAiB,EAE9B,CACA,kBAAmB,CACf,GAAI,CAAC,KAAK,UAAU,cAAgB,CAAC,KAAK,UAAU,aAAe,CAAC,KAAK,UAAU,UAC/E,OACJ,MAAMA,EAAiB,KAAK,UAAU,YAChChB,EAAe,KAAK,UAAU,aAE9BqB,EAAUL,EAAe,aAAa,4BAA4B,GAAG,WAAW,QAAQ,EAC9F,IAAIM,EAAgB,GAChBC,EAAe,KACfC,EAAiB,KACrB,GAAIH,EAAS,CAET,MAAMI,EAAcT,EAAe,WAC/BS,GAAezB,EAAa,aAAeyB,IAC3CF,EAAeE,EACfD,EAAiBR,EACjBM,EAAgB,GAExB,KACK,CAED,MAAMV,EAAY,KAAK,UAAU,UAAU,sBAAsB,EAC3Dc,EAAaV,EAAe,sBAAsB,EAClDF,EAAeF,EAAU,IAAMA,EAAU,OAAS,EAClDe,EAAgBD,EAAW,IAAMA,EAAW,OAAS,EACvDZ,EAAea,EAEX3B,EAAa,qBAAuBgB,IACpCO,EAAeP,EAAe,WAC9BQ,EAAiBR,EACjBM,EAAgB,IAKhBtB,EAAa,yBAA2BgB,IACxCO,EAAeP,EAAe,WAC9BQ,EAAiBR,EAAe,YAChCM,EAAgB,GAG5B,CAEIA,GAAiBC,GAAgBC,IAAmB,QACpD,KAAK,qBAAqBD,EAAcC,CAAc,EAGtDF,GACA,KAAK,wBAAwB,CAErC,CACA,qBAAqBC,EAAcC,EAAgB,CAE/C,MAAMI,EAAW,SAAS,iBAAiB,8BAA8B,EACnEC,EAAkB,IAAI,IAC5BD,EAAS,QAAQ7B,GAAQ,CACrB8B,EAAgB,IAAI9B,EAAMA,EAAK,sBAAsB,CAAC,CAC1D,CAAC,EAEGyB,EACAD,EAAa,aAAa,KAAK,UAAU,aAAcC,CAAc,EAGrED,EAAa,YAAY,KAAK,UAAU,YAAY,EAGxDK,EAAS,QAAQ7B,GAAQ,CACrB,MAAM+B,EAAaD,EAAgB,IAAI9B,CAAI,EAC3C,GAAI,CAAC+B,EACD,OACJ,MAAMC,EAAYhC,EAAK,sBAAsB,EACvCM,EAASyB,EAAW,KAAOC,EAAU,KACrCzB,EAASwB,EAAW,IAAMC,EAAU,KAEtC,KAAK,IAAI1B,CAAM,EAAI,IAAO,KAAK,IAAIC,CAAM,EAAI,KAC7C,KAAK,eAAeP,EAAMM,EAAQC,CAAM,CAEhD,CAAC,CACL,CACA,eAAe0B,EAAS3B,EAAQC,EAAQ,CAEpC,KAAK,UAAU,kBAAkB,IAAI0B,CAAO,EAE1BA,EAAQ,QAAQ,CAC9B,CAAE,UAAW,aAAa3B,CAAM,OAAOC,CAAM,KAAM,EACnD,CAAE,UAAW,iBAAkB,CACnC,EAAG,CACC,SAAU,IACV,OAAQ,UACZ,CAAC,EAES,iBAAiB,SAAU,IAAM,CACvC,KAAK,UAAU,kBAAkB,OAAO0B,CAAO,CACnD,CAAC,CACL,CACA,yBAA0B,CAEA,SAAS,iBAAiB,mCAAmC,EACrE,QAAQvB,GAAa,CAE/B,GADcA,EAAU,iBAAiB,8BAA8B,EAC7D,SAAW,EAAG,CAEpB,MAAMC,EAAY,KAAK,gBAAgB,EACvCD,EAAU,YAAYC,CAAS,EAC/B,KAAK,UAAU,WAAW,KAAKA,CAAS,CAC5C,CACJ,CAAC,CACL,CACA,wBAAyB,CACrB,KAAK,UAAU,YAAc,KAC7B,KAAK,UAAU,oBAAsB,IACzC,CACA,mBAAoB,CAChB,KAAK,UAAU,WAAW,QAAQC,GAAS,CACnCA,EAAM,YACNA,EAAM,WAAW,YAAYA,CAAK,CAE1C,CAAC,EACD,KAAK,UAAU,WAAa,CAAC,CACjC,CACA,iBAAkB,CACd,MAAMsB,EAAQ,CAAC,EAEf,OADmB,SAAS,iBAAiB,mCAAmC,EACrE,QAAQxB,GAAa,CAC5B,MAAMyB,EAAczB,EAAU,aAAa,iCAAiC,EACtE0B,EAAQ1B,EAAU,iBAAiB,8BAA8B,EAEjE2B,EAAY,MAAM,KAAKD,CAAK,EAAE,OAAOpC,GAGhC,GAFQA,EAAK,aAAa,4BAA4B,GAAK,IAC3C,WAAW,QAAQ,GAAK,KAAK,UAAU,WAAW,SAASA,CAAI,EAEzF,EACDkC,EAAMC,CAAW,EAAIE,EAAU,IAAI,CAACrC,EAAMsC,KAAW,CACjD,GAAItC,EAAK,aAAa,4BAA4B,GAAK,GACvD,KAAMA,EAAK,aAAe,GAC1B,SAAUsC,CACd,EAAE,CACN,CAAC,EACMJ,CACX,CAEA,OAAO,KAAKtC,EAAW,CACnB,OAAO,IAAID,EAAcC,CAAS,CACtC,CACJ,CAEA,eAAeD",
  "names": ["Intersortable", "callbacks", "styleElement", "event", "target", "item", "originalItem", "x", "y", "clone", "rect", "deltaX", "deltaY", "initialLeft", "initialTop", "container", "ghostItem", "ghost", "cloneRect", "cloneCenterX", "cloneCenterY", "nearestDistance", "nearestElement", "itemRect", "itemCenterX", "itemCenterY", "distance", "isGhost", "needsRecreate", "targetParent", "insertionPoint", "ghostParent", "targetRect", "targetCenterY", "allItems", "beforePositions", "beforeRect", "afterRect", "element", "state", "containerId", "items", "realItems", "index"]
}
